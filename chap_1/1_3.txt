1.3 关于数组

1.3.1 运用数组
	对应的程序实例为array.c
	需要提一下的就是：C的数组是从0开始的
	我想这不仅仅是一个历史遗留问题，使用0作为数组的开始会使程序编写时的一些运算更加简洁
	总之：如果习惯了，从0开始的数组比从1开始的数组，使用起来要方便很多
	
	我在知乎上回答的一个问题：
	前桥和弥先生所著的《征服C指针》（中文版吴雅明翻译）中对这个问题给出了一个简短的说明，我觉得很有比较有道理，挺有启发的。

	他为了说明这个问题，举了3个实际生活中的例子：

	（1）假设你上班的地方位于一座5层的写字楼里，你爬1层楼需要10秒，那么请问你爬上5楼需要花费多少时间？ 

	为了正确计算这个问题，我们需要使用的是：10秒*(5-1)=40秒；

	（2）等差数列第n项的值为：初项+公差*(n-1)；

	（3）我们都知道20世纪是19**年，19世纪是18**年，嗯，我记得以前学历史的时候经常还得思考一会才知道一些事件所发生的世纪……

	对于以上3个问题如果分别按照如下处理：

	（1）写字楼和地面相同的高度的那一层，计数为0层；

	（2）数列最初的项，计数为第0项；

	（3）最初的世纪计数为0世纪。

	就能够回避在计算或者理解问题时的一些不方便，比如这时候：

	（1）你从0层爬到4层需要多少时间，就可以脱口而出40秒；

	（2）等差数列的通项公式就可以更简洁地表达为：初项+公差*n；

	（3）19世纪对应的就是19**年……等等等等


	另外书中还举了一个编程中的例子，假设你需要使用一维数组去代替二维数组使用，

	/* width为行的宽度，引用第line行，第col列的元素*/
	array[line * width + col]
	假设最初的行为第1行，最初的列为第1列，数组下标也是从1开始的，那么，上面的代码就需要改成下面这样：

	array[(line-1) * width + (col-1)]
	<我自己的补充：下标从0开始，会使编程时产生的代码更加优美和直观一些>

	书中提到：如果你使用习惯了，从0开始的数组比从1开始的数组，使用起来方便得多。

1.3.2 数组和指针的微妙关系
	“至少在我看来，无论写成p++还是*(p+i)，都不容易阅读，还是最初的例子中array[i]这样的方式更容易理解。”
	实际上本书的主张是：“因为利用指针的方式不容易阅读，所以让我们抛弃这种写法吧。

1.3.3 下标运算法[]和数组是没有关系的
	首先这种说法：
		”在C中，如果在数组名后面不加[]，单独地只写数组名，那么此名称就表示<指向数组初始元素的指针>“是错误的。
	通过例子array4.c和array5.c可以看出来，*(p+i)和p[i]是同样的意思，可以认为后面这种写法是前面那种写法的简便写法（语法糖）。
	通过array.c中，数组越界之后依然可以输出数值来看，确实[]是与数组没有关系的，这的就是只是*(p+i)这种写法的简写。

	在表达式中（注意不是在数组的声明中）下标运算符和数组无关，也就是下标运算实际上是一个可有可无的运算符。

	（1）在表达式中，数组可以解读成”指向它的初始元素的指针“这和在不在后面加上下标运算符[]没有关系。
	（2）p[i]是*(p+i)的简便写法
	（3）下标运算符[]原本只有这种用法，它和数组无关

	需要注意的是，这里的[]是指在表达式中的[]，在数组声明中的[]是不一样的。

	那么既然p[i]是*(p+i)的简便写法，那么，其实i[p]等价于p[i]

1.3.4 为什么存在奇怪的指针运算
	试图访问数组的内容，老老实实使用下标访问就可以了，完全没有必要耍花招。
	C语言给人留下偏爱指针运算的印象是因为，在早先，使用指针可以写出相对高效的程序。
	在K&R中有下述论述：
	”Pointers are much used in C, partly because they are sometimes the only way to express a computation, 
	and partly because they usually lead to more compact and efficient code than can be obtained in other ways."
	
	但是，确实，无论如何，这都是老黄历了。
	如今，编译器在不断被优化，其实无论你写成什么样，经过编译器编译之后的机器码可能都是一样的，所以将精力花在其他更有意义的事情上比较好。

1.3.5 不要滥用指针运算

	其实在K&R中，有许多滥用指针的例程
	补充：修改参数，好吗？
		对值进行修改并没有任何语法上的问题，但是前桥和弥先生提出了一下观点，我觉得有必要记下：
		”函数的参数是从调用方得到的非常重要的信息，如果一时疏忽错误地修改了参数，就再也恢复不了了。
		对于在后面追加新的逻辑，或者调试程序的情况下，因为原始的参数已经被修改，如果想要看一下参数的值，你会感觉非常棘手。“

1.3.6 试图将数组作为函数的参数进行传递
	参见例程get_word.c
	准确地说，在C中是不能讲数组作为函数参数进行传递的。但是可以通过传递指向初始元素的指针来达到将数组作为参数进行传递的目的。
	如果执意要使用数组的副本作为参数进行传递，可行的方法是将数组整理成结构体
	C语言本来是只使用标量的语言，但是现在这种情况已经得到了改善，已经可以对结构体进行整体赋值了。
	但是真的要把数组作为参数进行传递的话，效率上可能是有问题的，因为如果数组非常大的话，就需要对这个非常大的数组进行复制，这显然不是一种明智的做法。

1.3.7 声明函数形参的方法
	一般的传递指向数组首个元素的指针的定义形式如下：
		int func(int* a)
	但是下面这种定义方法也是可以的：
		int func(int a[])
	编译器可以有针对性地解读成为：
		int func(int* a)
	及时你写成如下的形式，也是一样的：
		int func(int a[10])
	编译器对于你写的元素个数(10)是无视的。

	C语言为什么不做数组下标越界检查
	C语言对数组长度范围是不做检查的，这样就极有可能向数组越界写入数据的时候，产生内存被破坏的问题
	我们在程序中频繁使用越界检查会影响程序效率，而要求编译器替我们进行越界检查是不切实际的，也是编译器力所不能及的（不要存在这种幻想，不只C语言的编译器做不到，大部分的非解释型语言的编译器都做不到的）
	所以综上所述，使用C语言，尤其是使用C语言的数组，只有提高自己的水平这一条途径！







